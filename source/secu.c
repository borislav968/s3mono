
#include <avr/io.h>
#include <avr/interrupt.h>

// Число шагов РХХ
uint16_t _steps_max;

// Положение РХХ в шагах, 0.._steps_max
volatile uint16_t _steps = 0;

// Настройка обмена с SECU-3
void init_secu_connection( volatile uint16_t** steps, uint16_t steps_max ) {
    
    // Настройка таймера 1 - эмуляция ДПДЗ для SECU
    DDRB |= (1<<PB1);       // PB1 - выход ШИМ-сигнала положения дросселя
    TCCR1A |= (1<<COM1A1);  // Подключение PB1 к выходу таймера 1, без инверсии
    TCCR1A |= (1<<WGM10);   // Режим таймера - ШИМ с правильной фазой, 8 бит
    OCR1A = 0;              // Скважность 0
    TCCR1B |= (1<<CS10);    // Частота 8МГц / 1 / 256 = 31.25кГц

    // INT0 (PD2) - вход шагов РХ Х от SECU-3
    MCUCR |= (1<<ISC01);    // прерывание INT0 по отрицательному фронту на входе
    GICR |= (1<<INT0);      // включить INT0
    
    // INT1 (PD3) - вход управляющего сигнала форсунки
    MCUCR |= (1<<ISC10);    // Прерывание INT1 по любому изменению логического уровня на входе
    GICR |= (1<<INT1);      // Включить INT1

    // Драйверы форсунки
    DDRC |= (1<<PC3);       // Выход на открывающий драйвер форсунки
    DDRC |= (1<<PC4);       // Выход на удерживающий драйвер форсунки

    // Настройка компаратора
    ACSR |= (1<<ACIS1);     // Срабатывание по отрицательному фронту
    ACSR |= (1<<ACIE);      // Включить прерывание компаратора    
    
    _steps_max = steps_max; // число шагов РХХ
    
    *steps = &_steps;       // привязка указателя на текущее число шагов
    
}


// Положение ДПДЗ для SECU
// value 0..255 соответствует напряжению 0..5В на выходе
void secu_set_tps (uint8_t value) {
    OCR1A = value;
}

// Обработчик прерывания INT0
// сигнал шагов РХХ
ISR (INT0_vect) {
    
    if (PIND & (1<<PD4)) {                  // высокий уровень на входе DIR (PD4) - уменьшение
        if (_steps) _steps--;               // уменьшить на 1, если не 0
    } else {                                // низкий уровень на входе DIR - увеличение
        if (_steps < _steps_max) _steps++;  // увеличить на 1, если меньше _steps_max
    }
    
}

// Обработчик прерывания INT1
// сигнал управления форсункой

ISR (INT1_vect) {
    if (PIND & (1<<PD3))                    // Если на входе 1 (вход инверсный),
        PORTC &= ~((1<<PC3) | (1<<PC4));    // отключить оба драйвера форсунки,
    else
        PORTC |= (1<<PC3) | (1<<PC4);       // иначе включить их.
}


// Обработчик прерывания от компаратора
// ток форсунки достиг 4А

ISR (ANA_COMP_vect) {
    PORTC &= ~(1<<PC3);  // отключить открывающий драйвер, оставив только удерживающий.
}


